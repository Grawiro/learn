% python
>>> nudge = 1
>>> wink = 2
>>> A, B = nudge, wink                       # Przypisanie krotki
>>> A, B                                     # Jak A = nudge; B = wink
(1, 2)
>>> [C, D] = [nudge, wink]                   # Przypisanie listy
>>> C, D
(1, 2)


>>> nudge = 1
>>> wink = 2
>>> nudge, wink = wink, nudge                # Krotki: zamiana wartości
>>> nudge, wink                              # Jak T = nudge; nudge = wink; wink = T
(2, 1)


>>> [a, b, c] = (1, 2, 3)                    # Przypisanie krotki wartości do listy nazw
>>> a, c
(1, 3)
>>> (a, b, c) = "ABC"                        # Przypisanie łańcucha znaków do krotki
>>> a, c
('A', 'C')


>>> string = 'JAJO'
>>> a, b, c, d = string                      # Ta sama liczba elementów po obu stronach
>>> a, d
('J', 'O')

>>> a, b, c = string                         # Błąd: różna liczba elementów
...pominięto tekst błędu...
ValueError: too many values to unpack


>>> a, b, c = string[0], string[1], string[2:] # Indeksowanie i wycinek
>>> a, b, c
('J', 'A', 'JO')

>>> a, b, c = list(string[:2]) + [string[2:]]  # Wycinek i konkatenacja
>>> a, b, c
('J', 'A', 'JO')

>>> a, b = string[:2]                          # To samo w prostszej formie
>>> c = string[2:]
>>> a, b, c
('J', 'A', 'JO')

>>> (a, b), c = string[:2], string[2:]         # Zagnieżdżone sekwencje
>>> a, b, c
('J', 'A', 'JO')


>>> ((a, b), c) = ('JA', 'JO')               # Połączone w pary zgodnie z kształtem i pozycją
>>> a, b, c
('J', 'A', 'JO')


for (a, b, c) in [(1, 2, 3), (4, 5, 6)]: ...          # Proste przypisanie do krotki
for ((a, b), c) in [((1, 2), 3), ((4, 5), 6)]: ...    # Zagnieżdżone przypisanie do krotki


def f(((a, b), c)):              # Również dla argumentów w Python 2.6, ale nie 3.0
f(((1, 2), 3))


>>> red, green, blue = range(3)
>>> red, blue
(0, 2)


>>> range(3)                                 # W Pythonie 3.0 można spróbować list(range(3))
[0, 1, 2]


>>> L = [1, 2, 3, 4]
>>> while L:
...    front, L = L[0], L[1:]              # Wersja dla 3.0 przedstawiona w następnym punkcie
...    print front, L
...
1 [2, 3, 4]
2 [3, 4]
3 [4]
4 []


C:\misc> c:\python30\python
>>> seq = [1, 2, 3, 4]
>>> a, b, c, d = seq
>>> print(a, b, c, d)
1 2 3 4
>>> a, b = seq
ValueError: too many values to unpack


>>> a, *b = seq
>>> a
1
>>> b
[2, 3, 4]


>>> *a, b = seq
>>> a
[1, 2, 3]
>>> b
4


>>> a, *b, c = seq
>>> a
1
>>> b
[2, 3]
>>> c
4


>>> a, b, *c = seq
>>> a
1
>>> b
2
>>> c
[3, 4]


>>> a, *b = 'spam'
>>> a, b
('s', ['p', 'a', 'm'])

>>> a, *b, c = 'spam'
>>> a, b, c
('s', ['p', 'a'], 'm')


>>> S = 'spam'

>>> S[0], S[1:]                   # Wycinki są zależne od typu, przypisanie * zawsze zwraca listę
('s', 'pam')

>>> S[0], S[1:3], S[3]
('s', 'pa', 'm')


>>> L = [1, 2, 3, 4]
>>> while L:
...     front, *L = L             # Pobieramy pierwszy element i listę pozostałych, bez wycinania
...     print(front, L)
...
1 [2, 3, 4]
2 [3, 4]
3 [4]
4 []


>>> seq
[1, 2, 3, 4]

>>> a, b, c, *d = seq
>>> print(a, b, c, d)
1 2 3 [4]


>>> a, b, c, d, *e = seq
>>> print(a, b, c, d, e)
1 2 3 4 []

>>> a, b, *e, c, d = seq
>>> print(a, b, c, d, e)
1 2 3 4 []


>>> a, *b, c, *d = seq
SyntaxError: two starred expressions in assignment

>>> a, b = seq
ValueError: too many values to unpack

>>> *a = seq
SyntaxError: starred assignment target must be in a list or tuple

>>> *a, = seq
>>> a
[1, 2, 3, 4]


>>> seq
[1, 2, 3, 4]

>>> a, *b = seq                        # Pierwszy, pozostałe
>>> a, b
(1, [2, 3, 4])

>>> a, b = seq[0], seq[1:]             # Pierwszy, pozostałe: metoda tradycyjna
>>> a, b
(1, [2, 3, 4])


>>> *a, b = seq                        # Początek, ostatni
>>> a, b
([1, 2, 3], 4)

>>> a, b = seq[:-1], seq[-1]           # Początek, ostatni: metoda tradycyjna
>>> a, b
([1, 2, 3], 4)


for (a, *b, c) in [(1, 2, 3, 4), (5, 6, 7, 8)]:
    ...


a, *b, c = (1, 2, 3, 4)                            # b ma wartość [2, 3]


for (a, b, c) in [(1, 2, 3), (4, 5, 6)]:           # a, b, c = (1, 2, 3), …


for all in [(1, 2, 3, 4), (5, 6, 7, 8)]:
    a, b, c = all[0], all[1:3], all[3]


>>> a = b = c = 'mielonka'
>>> a, b, c
('mielonka', 'mielonka', 'mielonka')


>>> c = 'mielonka'
>>> b = c
>>> a = b


>>> a = b = 0
>>> b = b + 1
>>> a, b
(0, 1)


>>> a = b = []
>>> b.append(42)
>>> a, b
([42], [42])


>>> a = []
>>> b = []
>>> b.append(42)
>>> a, b
([], [42])


X = X + Y                                    # Forma tradycyjna
X += Y                                       # Nowsza forma rozszerzona


>>> x = 1
>>> x = x + 1                                # Forma tradycyjna
>>> x
2

>>> x += 1                                   # Forma rozszerzona
>>> x
3


>>> S = "mielonka"
>>> S += "MIELONKA"                          # Niejawna konkatenacja
>>> S
'mielonkaMIELONKA'


>>> L = [1, 2]
>>> L = L + [3]                              # Konkatenacja: wolniej
>>> L
[1, 2, 3]
>>> L.append(4)                              # Szybciej, ale w miejscu
>>> L
[1, 2, 3, 4]


>>> L = L + [5, 6]                           # Konkatenacja: wolniej
>>> L
[1, 2, 3, 4, 5, 6]
>>> L.extend([7, 8])                         # Szybciej, ale w miejscu
>>> L
[1, 2, 3, 4, 5, 6, 7, 8]


>>> L += [9, 10]                             # Odwzorowane na L.extend([9, 10])
>>> L
[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]


>>> L = [1, 2]
>>> M = L                                    # L i M są referencjami do jednego obiektu
>>> L = L + [3, 4]                           # Konkatenacja tworzy nowy obiekt
>>> L, M                                     # Zmiana L, ale nie M
([1, 2, 3, 4], [1, 2])

>>> L = [1, 2]
>>> M = L
>>> L += [3, 4]                              # Ale += tak naprawdę oznacza extend
>>> L, M                                     # Również w M zmiana jest widoczna!
([1, 2, 3, 4], [1, 2, 3, 4])


>>> x = 0                                    # x powiązane z obiektem liczby całkowitej
>>> x = "Troll"                              # Teraz jest łańcuchem znaków
>>> x = [1, 2, 3]                            # A teraz listą


>>> x = print('spam')      # print jest w 3.0 wyrażeniem wywołania funkcji
spam
>>> print(x)               # najczęściej jest jednak stosowana jak instrukcja wyrażenia
None


>>> L = [1, 2]
>>> L.append(3)                              # append jest metodą modyfikującą listę w miejscu
>>> L
[1, 2, 3]


>>> L = L.append(4)                          # append zwraca None, a nie L
>>> print L                                  # Tracimy więc naszą listę!
None


C:\misc> c:\python30\python
>>>
>>> print()                                      # Wyświetla pustą linię

>>> x = 'mielonka'
>>> y = 99
>>> z = ['jajka']
>>>
>>> print(x, y, z)                               # Wyświetla 3 obiekty z domyślnym formatowaniem
mielonka 99 ['jajka']


>>> print(x, y, z, sep='')                       # Pominięcie separatora
mielonka99['jajka']
>>>
>>> print(x, y, z, sep=', ')                     # Niestandardowy separator
mielonka, 99, ['jajka']


>>> print(x, y, z, end='')                       # Pominięcie przejścia do nowego wiersza
mielonka 99 ['jajka']>>>
>>>
>>> print(x, y, z, end=''); print(x, y, z)       # Dwukrotne wypisanie tego samego wiersza
mielonka 99 ['jajka']mielonka 99 ['jajka']
>>> print(x, y, z, end='...\n')                  # Niestandardowa sekwencja zakończenia wiersza
mielonka 99 ['jajka']...
>>>


>>> print(x, y, z, sep='...', end='!\n')          # Wiele argumentów ze słowami kluczowymi
mielonka...99...['jajka']!
>>> print(x, y, z, end='!\n', sep='...')          # Kolejność nie ma znaczenia
mielonka...99...['jajka']!


>>> print(x, y, z, sep='...', file=open('data.txt', 'w'))    # Wypisanie do pliku
>>> print(x, y, z)                                           # Powrót do standardowego wyjścia
mielonka 99 ['jajka']
>>> print(open('data.txt').read())                           # Wyświetlenie pliku tekstowego
mielonka...99...['jajka']


>>> text = '%s: %-.4f, %05d' % ('Wynik', 3.14159, 42)
>>> print(text)
Wynik: 3.1416, 00042
>>> print('%s: %-.4f, %05d' % ('Wynik', 3.14159, 42))
Wynik: 3.1416, 00042


C:\misc> c:\python26\python
>>>
>>> x = 'a'
>>> y = 'b'
>>> print x, y
a b


>>> print x, y,; print x, y
a b a b


>>> print x + y
ab
>>> print '%s...%s' % (x, y)
a...b


>>> print('witaj świecie')                  # Wyświetlenie ciągu znaków w Pythonie 3.0
witaj świecie

>>> print 'witaj świecie'                   # Wyświetlenie ciągu znaków w Pythonie 2.6
witaj świecie


>>> 'hello world'                           # Interaktywne wyświetlanie wartości
'witaj świecie'


>>> import sys                              # Wyświetlanie metodą "plikową"
>>> sys.stdout.write('witaj świecie\n')
witaj świecie


print(X, Y)                                 # albo w Pythonie 2.6: print X, Y 


import sys
sys.stdout.write(str(X) + ' ' + str(Y) + '\n')


import sys
sys.stdout = open('log.txt', 'a')            # Przekierowuje print do pliku
...
print x, y, x                                # Pokazuje się w log.txt


C:\misc> c:\python30\python
>>> import sys
>>> temp = sys.stdout                       # Zapisanie na później
>>> sys.stdout = open('log.txt', 'a')       # Przekierowanie do pliku
>>> print('mielonka')                       # Wypisuje do pliku, nie na ekran
>>> print(1, 2, 3)
>>> sys.stdout.close()                      # Opróżnienie bufora zapisu
>>> sys.stdout = temp                       # Przywrócenie oryginalnego strumienia

>>> print('znów jestem')                    # Wynik znowu pojawia się na ekranie
znów jestem
>>> print(open('log.txt').read())           # Rezultat wcześniejszego wypisywania
mielonka
1 2 3


log =  open('log.txt', 'a')             # 3.0
print(x, y, z, file=log)                # Zapis do obiektu podobnego do pliku
print(a, b, c)                          # Zapis do oryginalnego stdout

log =  open('log.txt', 'a')             # 2.6
print >> log, x, y, z                   # Zapis do obiektu podobnego do pliku
print a, b, c                           # Zapis do oryginalnego stdout


C:\misc> c:\python30\python
>>> log = open('log.txt', 'w')
>>> print(1, 2, 3, file=log)            # 2.6: print >> log, 1, 2, 3
>>> print(4, 5, 6, file=log)
>>> log.close()
>>> print(7, 8, 9)                      # 2.6: print 7, 8, 9
7 8 9
>>> print(open('log.txt').read())
1 2 3
4 5 6


>>> import sys
>>> sys.stderr.write(('Źle!' * 8) + '\n')
Źle!Źle!Źle!Źle!Źle!Źle!Źle!Źle!

>>> print ('Źle!' * 8, file=sys.stderr,)    # 2.6: print >> sys.stderr, 'Źle!' * 8
Źle!Źle!Źle!Źle!Źle!Źle!Źle!Źle!


>>> X = 1; Y = 2
>>> print(X, Y)                                            # Wyświetlanie: metoda standardowa
1 2
>>> import sys                                             # Wyświetlanie: metoda plikowa
>>> sys.stdout.write(str(X) + ' ' + str(Y) + '\n')
1 2
4
>>> print(X, Y, file=open('temp1', 'w'))                   # Przekierowanie do pliku

>>> open('temp2', 'w').write(str(X) + ' ' + str(Y) + '\n') # Bezpośredni zapis do pliku
4
>>> print(open('temp1', 'rb').read())                      # Binarny tryb odczytu
b'1 2\r\n'
>>> print(open('temp2', 'rb').read())
b'1 2\r\n'


from __future__ import print_function


C:\misc> c:\python30\python
>>> print('mielonka')                       # Wywołanie funkcji print w 3.0
mielonka
>>> print('mielonka', 'szynka', 'jajka')    # użycie kilku argumentów
mielonka szynka jajka


C:\misc> c:\python26\python
>>> print('mielonka')                       # Instrukcja print w 2.6 z użyciem nawiasów
mielonka
>>> print('mielonka', 'szynka', 'jajka')    # To w rzeczywistości obiekt krotki!
('mielonka', 'szynka', 'jajka')


>>> print('%s %s %s' % ('mielonka', 'szynka', 'jajka'))
mielonka szynka jajka
>>> print('{0} {1} {2}'.format('mielonka', 'szynka', 'jajka'))
mielonka szynka jajka


class FileFaker:
    def write(self, string):
        # Coś robi z łańcuchem znaków

import sys
sys.stdout = FileFaker()
print(someObjects)                         # Przesyła do metody write klasy


myobj = FileFaker()                        # 3.0: Przekierowanie do obiektu na tę jedną operację
print(someObjects, file= myobj)            # Nie przestawia sys.stdout

myobj = FileFaker()                        # 2.6: taki sam efekt
print >> myobj, someObjects                # Nie przestawia sys.stdout


python script.py < plik_wejściowy > plik_wyjściowy
python script.py | filterProgram
