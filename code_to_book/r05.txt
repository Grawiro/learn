>>> int(3.1415)                       # Odcina liczbę zmiennoprzecinkową do całkowitej
3
>>> float(3)                          # Przekształca liczbę całkowitą na zmiennoprzecinkową
3.0



>>> a = 3                                    # Utworzono zmienną (nazwę)
>>> b = 4



>>> a + 1, a - 1                             # Dodawanie (3 + 1), odejmowanie (3 – 1)
(4, 2)
>>> b * 3, b / 2                             # Mnożenie (4 * 3), dzielenie (4 / 2)
(12, 2)
>>> a % 2, b ** 2                            # Modulo (reszta z dzielenia), potęga (4 ** 2)
(1, 16)
>>> 2 + 4.0, 2.0 ** b                        # Konwersja typów mieszanych
(6.0, 16.0)



>>> c * 2
Traceback (most recent call last):
   File "<stdin>", line 1, in ?
NameError: name 'c' is not defined



>>> b / 2 + a                                # To samo co ((4 / 2) + 3)
5.0
>>> print(b / (2.0 + a))                     # To samo co (4 / (2.0 + 3))
0.8



>>> b / (2.0 + a)                            # Dane zwracane automatycznie — więcej cyfr
0.80000000000000004
>>> print(b / (2.0 + a))                     # Operacja print zaokrągla liczbę
0.8



>>> 1 / 2.0
0.5



>>> num = 1 / 3.0
>>> num                                      # Wyświetlenie wyniku
0.33333333333333331
>>> print(num)                               # Zaokrąglenie liczb za pomocą print
0.333333333333

>>> '%e' % num                               # Formatowanie za pomocą łańcuchów znaków
'3.333333e-001'
>>> '%4.2f' % num                            # Alternatywne formatowanie liczb zmiennoprzecinkowych
'0.33'
>>> '{0:4.2f}'.format(num)                   # Metoda formatowania za pomocą łańcuchów znaków (Python 2.6 i 3.0)
'0.33'



>>> num = 1 / 3
>>> repr(num)                                # Wyświetlanie w postaci jak w kodzie (sesja interaktywna)
'0.33333333333333331'
>>> str(num)                                 # Wyświetlanie w formie przyjaznej dla użytkownika (print)
'0.333333333333'



>>> 1 < 2                         # Mniejszy od
True
>>> 2.0 >= 1                      # Większy od bądź równy — mieszane typy, więc 1 przekształcone zostaje na 1.0
True
>>> 2.0 == 2.0                    # Równa wartość
True
>>> 2.0 != 2.0                    # Nie mają równej wartości
False



>>> X = 2
>>> Y = 4
>>> Z = 6



>>> X < Y < Z                                # Połączone porównania — testy przedziału
True
>>> X < Y and Y < Z
True



>>> X < Y > Z
False
>>> X < Y and Y > Z
False
>>> 1 < 2 < 3.0 < 4
True
>>> 1 > 2 > 3.0 > 4
False

>>> 1 == 2 < 3                               # To samo co: 1 == 2 i 2 < 3
False                                        # Nie to samo co: False < 3 (co oznacza 0 < 3 i jest prawdą)



C:\misc> C:\Python30\python
>>>
>>> 10 / 4                                   # Inaczej niż w 3.0 — zachowuje resztę
2.5
>>> 10 // 4                                  # Tak jak w 3.0 — odcina resztę
2
>>> 10 / 4.0                                 # Tak jak w 3.0 — zachowuje resztę
2.5
>>> 10 // 4.0                                # Tak jak w 3.0 — odcina resztę
2.0

C:\misc> C:\Python26\python
>>>
>>> 10 / 4
2
>>> 10 // 4
2
>>> 10 / 4.0
2.5
>>> 10 // 4.0
2.0



C:\misc> C:\Python26\python
>>> from __future__ import division          # Włączenie obsługi "/" z wersji 3.0
>>> 10 / 4
2.5
>>> 10 // 4
2



>>> import math
>>> math.floor(2.5)
2
>>> math.floor(-2.5)
-3
>>> math.trunc(2.5)
2
>>> math.trunc(-2.5)
-2



C:\misc> c:\python30\python
>>> 5 / 2, 5 / −2
(2.5, −2.5)

>>> 5 // 2, 5 // −2             # Odcina resztę do podstawy — zaokrągla do pierwszej mniejszej liczby całkowitej
(2, −3)                         # 2.5 staje się 2, −2.5 staje się −3

>>> 5 / 2.0, 5 / −2.0
(2.5, −2.5)

>>> 5 // 2.0, 5 // −2.0         # Tak samo w przypadku liczb zmiennoprzecinkowych, choć tu wynik jest także liczbą zmiennoprzecinkową
(2.0, −3.0)



C:\misc> c:\python26\python
>>> 5 / 2, 5 / −2               # Inaczej niż w 3.0
(2, −3)

>>> 5 // 2, 5 // −2             # Tu i poniżej wyniki w 2.6 i 3.0 są takie same
(2, −3)

>>> 5 / 2.0, 5 / −2.0
(2.5, −2.5)

>>> 5 // 2.0, 5 // −2.0
(2.0, −3.0)



C:\misc> c:\python30\python
>>> import math
>>> 5 / −2                             # Zachowanie reszty
−2.5
>>> 5 // −2                            # Zaokrąglenie wyniku w dół
-3
>>> math.trunc(5 / −2)                 # Odcięcie reszty zamiast zaokrąglenia w dół
−2

C:\misc> c:\python26\python
>>> import math
>>> 5 / float(−2)                      # Reszta w wersji 2.6
−2.5
>>> 5 / −2, 5 // −2                    # Zaokrąglenie w dół w wersji 2.6
(−3, −3)
>>> math.trunc(5 / float(−2))          # Odcięcie reszty w wersji 2.6
−2



# Jeśli korzystamy z Pythona 3.0, oto krótkie podsumowanie sposobu działania operatorów dzielenia:
>>> (5 / 2), (5 / 2.0), (5 / −2.0), (5 / −2)             # Prawdziwe dzielenie w 3.0
(2.5, 2.5, −2.5, −2.5)

>>> (5 // 2), (5 // 2.0), (5 // −2.0), (5 // −2)         # Dzielenie bez reszty w 3.0
(2, 2.0, −3.0, −3)

>>> (9 / 3), (9.0 / 3), (9 // 3), (9 // 3.0)             # Oba
(3.0, 3.0, 3, 3.0)

# U osób korzystających z wersji 2.6 dzielenie działa następująco:
>>> (5 / 2), (5 / 2.0), (5 / −2.0), (5 / −2)             # Dzielenie klasyczne w 2.6
(2, 2.5, −2.5, −3)

>>> (5 // 2), (5 // 2.0), (5 // −2.0), (5 // −2)         # Dzielenie bez reszty w 2.6 (to samo)
(2, 2.0, −3.0, −3)

>>> (9 / 3), (9.0 / 3), (9 // 3), (9 // 3.0)             # Oba
(3, 3.0, 3, 3.0)



>>> 999999999999999999999999999999 + 1
1000000000000000000000000000000

>>> 999999999999999999999999999999 + 1
1000000000000000000000000000000L             # 2.6

>>> 2 ** 200
1606938044258990275541962092341162602522202993782792835301376

>>> 2 ** 200
1606938044258990275541962092341162602522202993782792835301376L    # 2.6



>>> 1j * 1J
(-1+0j)
>>> 2 + 1j * 3
(2+3j)
>>> (2 + 1j) * 3
(6+3j)



>>> 0o1, 0o20, 0o377                         # Literały ósemkowe
(1, 16, 255)
>>> 0x01, 0x10, 0xFF                         # Literały szesnastkowe
(1, 16, 255)
>>> 0b1, 0b10000, 0b11111111                 # Literały dwójkowe
(1, 16, 255)



>>> oct(64), hex(64), bin(64)
('0100', '0x40', '0b1000000')

>>> int('64'), int('100', 8), int('40', 16), int('1000000', 2)
(64, 64, 64, 64)

>>> int('0x40', 16), int('0b1000000', 2)     # Literały też są w porządku
(64, 64)

>>> eval('64'), eval('0o100'), eval('0x40'), eval('0b1000000')
(64, 64, 64, 64)



>>> '{0:o}, {1:x}, {2:b}'.format(64, 64, 64)
'100, 40, 1000000'

>>> '%o, %x, %X' % (64, 255, 255)
'100, ff, FF'


>>> 0o1, 0o20, 0o377                         # Nowy format ósemkowy w 2.6 (ten sam co w 3.0)
(1, 16, 255)

>>> 01, 020, 0377                            # Stare literały ósemkowe w 2.6 (i wcześniejszych wersjach)
(1, 16, 255)



# Uwaga: w poniższych przykładach uruchamianych w Pythonie 2.X
# na końcu liczb pojawia się litera "L". Zgodnie z informacjami
# zamieszczonymi we wcześniejszej części rozdziału, w wersji 3.X
# tak nie jest (wynik pochodzi z wersji 2.X). Przykłady zostały
# uruchomione w Pythonie 2.6 w celu ukazania typu długiej liczby
# całkowitej utworzonej, by uzyskać dodatkową precyzję. W wersji 3.0
# działa to tak samo, jednak L nie będzie widoczne.
 
>>> X = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF
>>> X
5192296858534827628530496329220095L
>>> oct(X)
'017777777777777777777777777777777777777L'
>>> bin(X)
'0b1111111111111111111111111111111111111111111111111111111111 ...i tak dalej...


# Wynik dla Pythona 3.X będzie następujący
>>> X = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF
>>> X
5192296858534827628530496329220095
>>> oct(X)
'0o17777777777777777777777777777777777777'
>>> bin(X)
'0b11111111111111111111111111111111111111111111 ...to samo...



>>> x = 1                                    # 0001
>>> x << 2                                   # Przesunięcie o 2 bity w lewo: 0100
4
>>> x | 2                                    # Bitowe OR: 0011
3
>>> x & 1                                    # Bitowe AND: 0001
1



>>> X = 0b0001                               # Literały dwójkowe
>>> X << 2                                   # Przesunięcie w lewo
4
>>> bin(X << 2)                              # Łańcuch cyfr dwójkowych
'0b100'

>>> bin(X | 0b010)                           # Bitowe OR
'0b11'
>>> bin(X & 0b1)                             # Bitowe AND
'0b1'

>>> X = 0xFF                                 # Literały szesnastkowe
>>> bin(X)
'0b11111111'
>>> X ^ 0b10101010                           # Bitowe XOR
85
>>> bin(X ^ 0b10101010)
'0b1010101'

>>> int('1010101', 2)                        # Łańcuch znaków na liczbę całkowitą zgodnie z podstawą
85
>>> hex(85)                                  # Łańcuch cyfr szesnastkowych
'0x55'



>>> X = 99
>>> bin(X), X.bit_length()
('0b1100011', 7)
>>> bin(256), (256).bit_length()
('0b100000000', 9)
>>> len(bin(256)) - 2
9



>>> import math
>>> math.pi, math.e                          # Często używane stałe
(3.1415926535897931, 2.7182818284590451)

>>> math.sin(2 * math.pi / 180)              # Sinus, tangens, cosinus
0.034899496702500969

>>> math.sqrt(144), math.sqrt(2)             # Pierwiastek kwadratowy
(12.0, 1.4142135623730951)

>>> pow(2, 4), 2 ** 4                        # Potęgowanie
(16, 16)

>>> abs(-42.0), sum((1, 2, 3, 4))            # Wartość bezwzględna, suma
(42.0, 10)

>>> min(3, 1, 2, 4), max(3, 1, 2, 4)         # Minimum, maksimum
(1, 4)



>>> math.floor(2.567), math.floor(-2.567)    # Zaokrąglenie do najbliższej mniejszej liczby całkowitej
(2, −3)

>>> math.trunc(2.567), math.trunc(−2.567)    # Odcięcie (pominięcie części ułamkowej)
(2, −2)

>>> int(2.567), int(−2.567)                  # Odcięcie (konwersja na liczbę całkowitą)
(2, −2)

>>> round(2.567), round(2.467), round(2.567, 2) # Zaokrąglenie (Python 3.0)
(3, 2, 2.5699999999999998)

>>> '%.1f' % 2.567, '{0:.2f}'.format(2.567)  # Zaokrąglenie na potrzeby wyświetlania (rozdział 7.)
('2.6', '2.57')



>>> (1 / 3), round(1 / 3, 2), ('%.2f' % (1 / 3))
(0.33333333333333331, 0.33000000000000002, '0.33')



>>> import math
>>> math.sqrt(144)                           # Moduł
12.0
>>> 144 ** .5                                # Wyrażenie
12.0
>>> pow(144, .5)                             # Funkcja wbudowana
12.0

>>> math.sqrt(1234567890)                    # Większe liczby
35136.418286444619
>>> 1234567890 ** .5
35136.418286444619
>>> pow(1234567890, .5)
35136.418286444619



>>> import random
>>> random.random()
0.44694718823781876
>>> random.random()
0.28970426439292829

>>> random.randint(1, 10)
5
>>> random.randint(1, 10)
4

>>> random.choice(['Żywot Briana', 'Święty Graal', 'Sens życia'])
'Żywot Briana'
>>> random.choice(['Żywot Briana', 'Święty Graal', 'Sens życia'])
'Święty Graal'



>>> 0.1 + 0.1 + 0.1 - 0.3
5.5511151231257827e-17

>>> print(0.1 + 0.1 + 0.1 - 0.3)
5.55111512313e-17

>>> from decimal import Decimal
>>> Decimal('0.1') + Decimal('0.1') + Decimal('0.1') - Decimal('0.3')
Decimal('0.0')

>>> Decimal('0.1') + Decimal('0.10') + Decimal('0.10') - Decimal('0.30')
Decimal('0.00')



>>> import decimal
>>> decimal.Decimal(1) / decimal.Decimal(7)
Decimal('0.1428571428571428571428571429')

>>> decimal.getcontext().prec = 4
>>> decimal.Decimal(1) / decimal.Decimal(7)
Decimal('0.1429')



>>> 1999 + 1.33
2000.3299999999999
>>>
>>> decimal.getcontext().prec = 2
>>> pay = decimal.Decimal(str(1999 + 1.33))
>>> pay
Decimal('2000.33')



C:\misc> C:\Python30\python
>>> import decimal
>>> decimal.Decimal('1.00') / decimal.Decimal('3.00')
Decimal('0.3333333333333333333333333333')
>>>
>>> with decimal.localcontext() as ctx:
...     ctx.prec = 2
...     decimal.Decimal('1.00') / decimal.Decimal('3.00')
...
Decimal('0.33')
>>>
>>> decimal.Decimal('1.00') / decimal.Decimal('3.00')
Decimal('0.3333333333333333333333333333')



>>> from fractions import Fraction
>>> x = Fraction(1, 3)                       # Licznik, mianownik
>>> y = Fraction(4, 6)                       # Uproszczony do 2, 3 przez gcd

>>> x
Fraction(1, 3)
>>> y
Fraction(2, 3)
>>> print(y)
2/3


>>> x + y
Fraction(1, 1)
>>> x – y                                    # Wyniki są dokładne: licznik, mianownik
Fraction(-1, 3)
>>> x * y
Fraction(2, 9)


>>> Fraction('.25')
Fraction(1, 4)
>>> Fraction('1.25')
Fraction(5, 4)
>>>
>>> Fraction('.25') + Fraction('1.25')
Fraction(3, 2)



>>> a = 1 / 3.0                          # Dokładność taka, jak procesora do obliczeń zmiennoprzecinkowych
>>> b = 4 / 6.0                          # Może w miarę obliczeń tracić precyzję
>>> a
0.33333333333333331
>>> b
0.66666666666666663

>>> a + b
1.0
>>> a - b
-0.33333333333333331
>>> a * b
0.22222222222222221


>>> 0.1 + 0.1 + 0.1 - 0.3                    # To powinno wynosić zero (blisko, ale nie dokładnie)
5.5511151231257827e-17

>>> from fractions import Fraction
>>> Fraction(1, 10) + Fraction(1, 10) + Fraction(1, 10) - Fraction(3, 10)
Fraction(0, 1)

>>> from decimal import Decimal
>>> Decimal('0.1') + Decimal('0.1') + Decimal('0.1') - Decimal('0.3')
Decimal('0.0')



>>> 1 / 3                        # W Pythonie 2.6 należy użyć "3.0" w celu uzyskania prawdziwego dzielenia
0.33333333333333331

>>> Fraction(1, 3)               # Dokładność liczb
Fraction(1, 3)

>>> import decimal
>>> decimal.getcontext().prec = 2
>>> decimal.Decimal(1) / decimal.Decimal(3)
Decimal('0.33')



>>> (1 / 3) + (6 / 12)           # W Pythonie 2.6 należy użyć ".0" w celu uzyskania prawdziwego dzielenia
0.83333333333333326

>>> Fraction(6, 12)              # Automatyczne skrócenie ułamka
Fraction(1, 2)

>>> Fraction(1, 3) + Fraction(6, 12)
Fraction(5, 6)

>>> decimal.Decimal(str(1/3)) + decimal.Decimal(str(6/12))
Decimal('0.83')

>>> 1000.0 / 1234567890
8.1000000737100011e-07

>>> Fraction(1000, 1234567890)
Fraction(100, 123456789)



>>> (2.5).as_integer_ratio()            #Metoda obiektu liczby zmiennoprzecinkowej
(5, 2)

>>> f = 2.5
>>> z = Fraction(*f.as_integer_ratio()) # Konwersja z liczby zmiennoprzecinkowej na ułamek: 2 argumenty
>>> z                                   # To samo co Fraction(5, 2)
Fraction(5, 2)

>>> x                                   # x z poprzedniej interakcji
Fraction(1, 3)
>>> x + z
Fraction(17, 6)                         # 5/2 + 1/3 = 15/6 + 2/6

>>> float(x)                            # Konwersja z ułamka na liczbę zmiennoprzecinkową
0.33333333333333331
>>> float(z)
2.5
>>> float(x + z)
2.8333333333333335
>>> 17 / 6
2.8333333333333335

>>> Fraction.from_float(1.75)           # Konwersja z liczby zmiennoprzecinkowej na ułamek: inny sposób
Fraction(7, 4)
>>> Fraction(*(1.75).as_integer_ratio())
Fraction(7, 4)



>>> x
Fraction(1, 3)
>>> x + 2                               # Ułamek + liczba całkowita -> ułamek
Fraction(7, 3)
>>> x + 2.0                             # Ułamek + liczba zmiennoprzecinkowa -> liczba zmiennoprzecinkowa
2.3333333333333335
>>> x + (1./3)                          # Ułamek + liczba zmiennoprzecinkowa -> liczba zmiennoprzecinkowa
0.66666666666666663

>>> x + (4./3)
1.6666666666666665
>>> x + Fraction(4, 3)                  # Ułamek + ułamek -> ułamek
Fraction(5, 3)



>>> 4.0 / 3
1.3333333333333333
>>> (4.0 / 3).as_integer_ratio()           # Utrata precyzji z liczby zmiennoprzecinkowej
(6004799503160661, 4503599627370496)

>>> x
Fraction(1, 3)
>>> a = x + Fraction(*(4.0 / 3).as_integer_ratio())
>>> a
Fraction(22517998136852479, 13510798882111488)

>>> 22517998136852479 / 13510798882111488. # 5 / 3 (lub niedaleko!)
1.6666666666666667

>>> a.limit_denominator(10)                # Uproszczenie do najbliższego ułamka
Fraction(5, 3)



>>> x = set('abcde')
>>> y = set('bdxyz')
>>> x
set(['a', 'c', 'b', 'e', 'd'])               # Format wyświetlania z wersji 2.6

>>> 'e' in x                                 # Istnienie w zbiorze
True

>>> x – y                                    # Różnica zbiorów
set(['a', 'c', 'e'])

>>> x | y                                    # Suma zbiorów
set(['a', 'c', 'b', 'e', 'd', 'y', 'x', 'z'])

>>> x & y                                    # Część wspólna zbiorów
set(['b', 'd'])

>>> x ^ y                                    # Różnica symetryczna (XOR)
set(['a', 'c', 'e', 'y', 'x', 'z'])

>>> x > y, x < y                             # Nadzbiór, podzbiór
(False, False)


>>> z = x.intersection(y)                    # To samo co x & y
>>> z
set(['b', 'd'])
>>> z.add('MIELONKA')                        # Wstawienie jednego elementu
>>> z
set(['b', 'd', 'MIELONKA'])
>>> z.update(set(['X', 'Y']))                # Połączenie: suma w miejscu
>>> z
set(['Y', 'X', 'b', 'd', 'MIELONKA'])
>>> z.remove('b')                            # Usunięcie jednego elementu
>>> z
set(['Y', 'X', 'd', 'MIELONKA'])


>>> for item in set('abc'): print(item * 3)
...
aaa
ccc
bbb

>>> S = set([1, 2, 3])

>>> S | set([3, 4])                          # Wyrażenie wymaga, by oba były zbiorami
set([1, 2, 3, 4])
>>> S | [3, 4]
TypeError: unsupported operand type(s) for |: 'set' and 'list'

>>> S.union([3, 4])                          # Metody zezwalają na typy, po których można iterować
set([1, 2, 3, 4])
>>> S.intersection((1, 3, 5))
set([1, 3])
>>> S.issubset(range(-5, 5))
True



C:\Misc> c:\python30\python
>>> set([1, 2, 3, 4])                     # Wbudowany konstruktor: tak samo jak w 2.6
{1, 2, 3, 4}
>>> set('mielonka')                       # Dodanie wszystkich elementów obiektu, po którym można iterować
{'a', 'e', 'i', 'k', 'm', 'l', 'o', 'n'}
>>> {1, 2, 3, 4}                          # Literały zbiorów: nowość w 3.0
{1, 2, 3, 4}
>>> S = {'m', 'i', 'e', 'l', 'o', 'n', 'k', 'a'}
>>> S.add('konserwowa')
>>> S
{'a', 'e', 'i', 'k', 'm', 'l', 'o', 'n', 'konserwowa'}


>>> S1 = {1, 2, 3, 4}
>>> S1 & {1, 3}                              # Część wspólna
{1, 3}
>>> {1, 5, 3, 6} | S1                        # Suma
{1, 2, 3, 4, 5, 6}
>>> S1 - {1, 3, 4}                           # Różnica
{2}
>>> S1 > {1, 3}                              # Nadzbiór
True


>>> S1 - {1, 2, 3, 4}                        # Puste zbiory wyświetlane są inaczej
set()
>>> type({})                                 # Ponieważ {} jest pustym słownikiem
<class 'dict'>

>>> S = set()                                # Inicjalizacja pustego zbioru
>>> S.add(1.23)
>>> S
{1.23}


>>> {1, 2, 3} | {3, 4}
{1, 2, 3, 4}
>>> {1, 2, 3} | [3, 4]
TypeError: unsupported operand type(s) for |: 'set' and 'list'

>>> {1, 2, 3}.union([3, 4])
{1, 2, 3, 4}
>>> {1, 2, 3}.union({3, 4})
{1, 2, 3, 4}
>>> {1, 2, 3}.union(set([3, 4]))
{1, 2, 3, 4}

>>> {1, 2, 3}.intersection((1, 3, 5))
{1, 3}
>>> {1, 2, 3}.issubset(range(-5, 5))
True


>>> S
{1.23}
>>> S.add([1, 2, 3])                         # W zbiorze działają jedynie obiekty niezmienne
TypeError: unhashable type: 'list'
>>> S.add({'a':1})
TypeError: unhashable type: 'dict'
>>> S.add((1, 2, 3))
>>> S                                        # Ani listy, ani słowniki; krotki są OK
{1.23, (1, 2, 3)}

>>> S | {(4, 5, 6), (1, 2, 3)}               # Suma: to samo co S.union(...)
{1.23, (4, 5, 6), (1, 2, 3)}
>>> (1, 2, 3) in S                           # Istnienie w zbiorze: porównanie po pełnej wartości
True
>>> (1, 4, 3) in S
False



>>> {x ** 2 for x in [1, 2, 3, 4]}           # Zbiory składane z wersji 3.0
{16, 1, 4, 9}

>>> {x for x in 'mielonka'}                  # To samo co: set('mielonka')
{'a', 'e', 'i', 'k', 'm', 'l', 'o', 'n'}

>>> {c * 4 for c in 'mielonka'}              # Zbiór zebranych wyników wyrażenia
{'iiii', 'eeee', 'oooo', 'nnnn', 'mmmm', 'aaaa', 'llll', 'kkkk'}
>>> {c * 4 for c in 'szynkajajka'}
{'yyyy', 'jjjj', 'nnnn', 'zzzz', 'ssss', 'aaaa', 'kkkk'}

>>> S = {c * 4 for c in 'mielonka'}
>>> S | {'mmmm', 'xxxx'}
{'mmmm', 'eeee', 'xxxx', 'oooo', 'nnnn', 'iiii', 'aaaa', 'llll', 'kkkk'}
>>> S & {'mmmm', 'xxxx'}
{'mmmm'}




>>> L = [1, 2, 1, 3, 2, 4, 5]
>>> set(L)
{1, 2, 3, 4, 5}
>>> L = list(set(L))                         # Usunięcie duplikatów
>>> L
[1, 2, 3, 4, 5]


>>> engineers = {'robert', 'amadeusz', 'anna', 'aleksander'}
>>> managers = {'edward', 'amadeusz'}

>>> 'robert' in engineers                    # Czy Robert jest inżynierem?
True

>>> engineers & managers                     # Kto jest inżynierem i menedżerem?
{'amadeusz'}

>>> engineers | managers                     # Wszystkie osoby z dowolnej kategorii
{'edward', 'amadeusz', 'anna', 'robert', 'aleksander'}

>>> engineers – managers                     # Inżynierowie niebędący menedżerami
{'robert', 'aleksander', 'anna'}

>>> managers – engineers                     # Menedżerowie niebędący inżynierami
{'edward'}

>>> engineers > managers                     # Czy wszyscy menedżerowie są inżynierami? (nadzbiór)
False

>>> {'robert', 'amadeusz'} < engineers       # Czy obaj są inżynierami? (podzbiór)
True

>>> (managers | engineers) > managers        # Nadzbiorem menedżerów są wszyscy ludzie
True

>>> managers ^ engineers                     # Kto jest w jednym zbiorze, ale nie obu?
{'robert', 'edward', 'aleksander', 'anna'}

>>> (managers | engineers) - (managers ^ engineers) # Część wspólna!
{'amadeusz'}



>>> type(True)
<class 'bool'>
>>> isinstance(True, int)
True
>>> True == 1                                # Ta sama wartość
True
>>> True is 1                                # Ale inny obiekt — patrz kolejny rozdział
False
>>> True or False                            # To samo co: 1 or 0
True
>>> True + 4                                 # (Hmmm)
5